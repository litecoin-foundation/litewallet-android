////  wallet.c////  Created by Mihail Gutan on 12/4/15.//  Copyright (c) 2015 breadwallet LLC////  Permission is hereby granted, free of charge, to any person obtaining a copy//  of this software and associated documentation files (the "Software"), to deal//  in the Software without restriction, including without limitation the rights//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell//  copies of the Software, and to permit persons to whom the Software is//  furnished to do so, subject to the following conditions:////  The above copyright notice and this permission notice shall be included in//  all copies or substantial portions of the Software.////  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN//  THE SOFTWARE.#include "wallet.h"#include "PeerManager.h"#include "BRPeerManager.h"#include "BRBIP39Mnemonic.h"#include "BRBase58.h"#include <android/log.h>#include "BRBIP32Sequence.h"#include "BRTransaction.h"static JavaVM *_jvmW;BRWallet *_wallet;static BRTransaction **_transactions;static size_t _transactionsCounter = 0;jclass _walletManagerClass;static JNIEnv* getEnv() {    if(!_jvmW) return NULL;    static JNIEnv *env;    int status = (*_jvmW)->GetEnv(_jvmW,(void**)&env, JNI_VERSION_1_6);    if(status < 0) {        status = (*_jvmW)->AttachCurrentThread(_jvmW, &env, NULL);        if(status < 0) {            return NULL;        }    }    return env;}//callback for tx publishingvoid callback(void *info, int error){    if(error){        __android_log_print(ANDROID_LOG_ERROR, "Message from callback: ", "publishing Failed: %s", strerror(error));    } else {        __android_log_print(ANDROID_LOG_ERROR, "Message from callback: ", "publishing Succeeded!");    }}static void balanceChanged(void *info, uint64_t balance) {    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "balanceChanged: %d", (int) balance);    JNIEnv *globalEnv = getEnv();    if(!globalEnv) return;    jmethodID mid = (*globalEnv)->GetStaticMethodID(globalEnv, _walletManagerClass, "onBalanceChanged", "(J)V");    //call java methods    (*globalEnv)->CallStaticVoidMethod(globalEnv, _walletManagerClass, mid, balance);    (*_jvmW)->DetachCurrentThread(_jvmW);}static void txAdded(void *info, BRTransaction *tx) {    if(!_wallet) return;    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "txAdded");    JNIEnv *globalEnv = getEnv();    if(!globalEnv) return;    jmethodID mid = (*globalEnv)->GetStaticMethodID(globalEnv, _walletManagerClass, "onTxAdded", "([BIJJLjava/lang/String;)V");    //call java methods    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "BRPeerManagerLastBlockHeight(): %d tx->timestamp: %d", tx->blockHeight, tx->timestamp);    uint8_t buf[BRTransactionSerialize(tx, NULL, 0)];    size_t len = BRTransactionSerialize(tx, buf, sizeof(buf));    uint64_t fee = BRWalletFeeForTx(_wallet, tx) == -1 ? 0 : BRWalletFeeForTx(_wallet, tx);    jlong amount;    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "fee: %d", (int) fee);    if (BRWalletAmountSentByTx(_wallet, tx) == 0) {        amount = BRWalletAmountReceivedFromTx(_wallet, tx);    } else {        amount = (BRWalletAmountSentByTx(_wallet, tx) - BRWalletAmountReceivedFromTx(_wallet, tx) - fee) * -1;    }    jbyteArray result = (*globalEnv)->NewByteArray(globalEnv, len);    (*globalEnv)->SetByteArrayRegion(globalEnv, result, 0, len, (jbyte *)buf);    UInt256 transactionHash = tx->txHash;    const char *strHash = uint256_hex_encode(transactionHash);    jstring jstrHash = (*globalEnv)->NewStringUTF(globalEnv, strHash);    (*globalEnv)->CallStaticVoidMethod(globalEnv, _walletManagerClass, mid, result, (jint) tx->blockHeight,                                 (jlong) tx->timestamp, (jlong) amount, jstrHash);    (*_jvmW)->DetachCurrentThread(_jvmW);}static void txUpdated(void *info, const UInt256 txHashes[], size_t count, uint32_t blockHeight,                      uint32_t timestamp) {    if(!_wallet) return;    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "txUpdated");    JNIEnv *globalEnv = getEnv();    if(!globalEnv) return;    jmethodID mid = (*globalEnv)->GetStaticMethodID(globalEnv, _walletManagerClass, "onTxUpdated", "(Ljava/lang/String;I)V");    for(size_t i = 0; i < count; i++){        const char *strHash = uint256_hex_encode(txHashes[i]);        jstring JstrHash = (*globalEnv)->NewStringUTF(globalEnv, strHash);        (*globalEnv)->CallStaticVoidMethod(globalEnv, _walletManagerClass, mid, JstrHash, (jint)blockHeight);    }    (*_jvmW)->DetachCurrentThread(_jvmW);}static void txDeleted(void *info, UInt256 txHash, int notifyUser, int recommendRescan) {    //TODO use notifyUser and recommendRescan    if(!_wallet) return;    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "txDeleted");    JNIEnv *globalEnv = getEnv();    if(!globalEnv) return;    const char *strHash = uint256_hex_encode(txHash);    //create class    jmethodID mid = (*globalEnv)->GetStaticMethodID(globalEnv, _walletManagerClass, "onTxDeleted", "(Ljava/lang/String;)V");//    //call java methods    (*globalEnv)->CallStaticVoidMethod(globalEnv, _walletManagerClass, mid, (*globalEnv)->NewStringUTF(globalEnv, strHash));    (*_jvmW)->DetachCurrentThread(_jvmW);}JNIEXPORT jbyteArray Java_com_breadwallet_wallet_BRWalletManager_encodeSeed(JNIEnv *env,                                                                            jobject thiz,                                                                            jbyteArray seed,                                                                            jobjectArray stringArray) {    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "encodeSeed");    int wordsCount = (*env)->GetArrayLength(env, stringArray);    int seedLength = (*env)->GetArrayLength(env, seed);    const char *wordList[wordsCount];    for (int i = 0; i < wordsCount; i++) {        jstring string = (jstring) (*env)->GetObjectArrayElement(env, stringArray, i);        const char *rawString = (*env)->GetStringUTFChars(env, string, 0);        wordList[i] = rawString;        (*env)->DeleteLocalRef(env, string);        // Don't forget to call `ReleaseStringUTFChars` when you're done.    }    jbyte *byteSeed = (*env)->GetByteArrayElements(env, seed, 0);    char result[BRBIP39Encode(NULL, 0, wordList, (uint8_t *) byteSeed, seedLength)];    BRBIP39Encode((char *) result, sizeof(result), wordList, (const uint8_t *) byteSeed, (size_t) seedLength);    jbyte *phraseJbyte = (jbyte *) result;    int size = sizeof(result);    jbyteArray bytePhrase = (*env)->NewByteArray(env, size);    (*env)->SetByteArrayRegion(env, bytePhrase, 0, size, phraseJbyte);    return bytePhrase;}JNIEXPORT void Java_com_breadwallet_wallet_BRWalletManager_createWallet(JNIEnv *env,                                                                        jobject thiz,                                                                        size_t txCount,                                                                        jbyteArray bytePubKey) {    BRMasterPubKey pubKey;//   int pubKeyLength = (*env)->GetArrayLength(env, bytePubKey);    jbyte *pubKeyBytes = (*env)->GetByteArrayElements(env, bytePubKey, 0);    pubKey = *(BRMasterPubKey *) pubKeyBytes;    jint rs = (*env)->GetJavaVM(env, &_jvmW); // cache the JavaVM pointer    jclass peerManagerCLass = (*env)->FindClass(env,"com/breadwallet/wallet/BRWalletManager");    _walletManagerClass = (jclass) (*env)->NewGlobalRef(env, (jobject) peerManagerCLass);//    if(_wallet) BRWalletFree(_wallet);    if (rs != JNI_OK) {        __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "WARNING, GetJavaVM is not JNI_OK");    }    int pubKeySize = sizeof(pubKey);    if (pubKeySize < 5) {        __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "WARNING, pubKey is corrupt!");        return;    }    if (!_transactions) {        __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "WARNING, _transactions is NULL, txCount: %zu", txCount);        txCount = 0;    }    if (txCount > 0) {        __android_log_print(ANDROID_LOG_ERROR, "Message from C: ",                            "CREATING WALLET FROM TXS - txCount: %zu", txCount);        _wallet = BRWalletNew(_transactions, txCount, pubKey);        _transactionsCounter = 0;        free(_transactions);    } else {        __android_log_print(ANDROID_LOG_INFO, "Message from C: ", "CREATING EMPTY WALLET");        _wallet = BRWalletNew(NULL, 0, pubKey);    }    BRWalletSetCallbacks(_wallet, NULL, balanceChanged, txAdded, txUpdated, txDeleted);    //create class    jclass clazz = (*env)->FindClass(env, "com/breadwallet/wallet/BRWalletManager");    jmethodID mid = (*env)->GetStaticMethodID(env, clazz, "onBalanceChanged", "(J)V");    //call java methods    (*env)->CallStaticVoidMethod(env, clazz, mid, BRWalletBalance(_wallet));}JNIEXPORT jbyteArray Java_com_breadwallet_wallet_BRWalletManager_getMasterPubKey(JNIEnv *env,                                                                                 jobject thiz,                                                                                 jstring phrase) {    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "getMasterPubKey");    const char *rawPhrase = (*env)->GetStringUTFChars(env, phrase, 0);    UInt512 key = UINT512_ZERO;    BRBIP39DeriveKey(key.u8, rawPhrase, NULL);    BRMasterPubKey pubKey = BRBIP32MasterPubKey(key.u8, sizeof(key));    size_t pubKeySize = sizeof(pubKey);//    char buff[BRBase58Encode(NULL, 0, &pubKey, pubKeySize)];////    BRBase58Encode(buff, sizeof(buff), &pubKey, pubKeySize);//    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "buff: %s", buff);    jbyte *pubKeyBytes = (jbyte *) &pubKey;    jbyteArray result = (*env)->NewByteArray(env, (jsize) pubKeySize);    (*env)->SetByteArrayRegion(env, result, 0, (jsize) pubKeySize, (const jbyte *)pubKeyBytes);    //release everything    (*env)->ReleaseStringUTFChars(env, phrase, rawPhrase);    return result;}//Call multiple times with all the transactions from the DBJNIEXPORT void Java_com_breadwallet_wallet_BRWalletManager_putTransaction(JNIEnv *env,                                                                                jobject thiz,                                                                                jbyteArray transaction,                                                                                jlong jBlockHeight,                                                                                jlong jTimeStamp) {    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "createTxArrayWithCount");    if(!_transactions) return;    int txLength = (*env)->GetArrayLength(env, transaction);    jbyte *byteTx = (*env)->GetByteArrayElements(env, transaction, 0);    BRTransaction *tmpTx = BRTransactionParse((uint8_t *) byteTx, txLength);    tmpTx->blockHeight = jBlockHeight;    tmpTx->timestamp = jTimeStamp;    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "_transactionsCounter: %zu", _transactionsCounter);    _transactions[_transactionsCounter++] = tmpTx;}JNIEXPORT void Java_com_breadwallet_wallet_BRWalletManager_createTxArrayWithCount(JNIEnv *env,                                                                                        jobject thiz,                                                                                        int txCount) {    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "createTxArrayWithCount: %d", txCount);//    _transactions = calloc(txCount, sizeof(*_transactions));    _transactionsCounter = 0;    // need to call free(transactions);}JNIEXPORT jstring Java_com_breadwallet_wallet_BRWalletManager_getReceiveAddress(JNIEnv *env,                                                                                jobject thiz) {    if(!_wallet) return NULL;    BRAddress receiveAddress = BRWalletReceiveAddress(_wallet);    return (*env)->NewStringUTF(env, receiveAddress.s);}JNIEXPORT jobjectArray Java_com_breadwallet_wallet_BRWalletManager_getTransactions(JNIEnv *env,                                                                                   jobject thiz) {    if (!_wallet ) return NULL;    if (BRWalletTransactions(_wallet, NULL, 0) == 0) return NULL;    //Retrieve the txs array    BRTransaction *transactions_sqlite[BRWalletTransactions(_wallet, NULL, 0)];    size_t temp = sizeof(transactions_sqlite) / sizeof(*transactions_sqlite);    __android_log_print(ANDROID_LOG_ERROR, "THIS IS THE TEMP: ", "temp: %d", (int) temp);    size_t txCount = BRWalletTransactions(_wallet, transactions_sqlite, temp);//    __android_log_print(ANDROID_LOG_ERROR, "***LOLOLOLOLOLOLO*********: ", "txCount: %d", txCount);//    return NULL;    //Find the class and populate the array of objects of this class    jclass txClass = (*env)->FindClass(env, "com/breadwallet/presenter/entities/TransactionListItem");    jobjectArray transactionObjects = (*env)->NewObjectArray(env, txCount, txClass, 0);    for (int i = 0; i < txCount; i++) {        if(!_wallet) return NULL;        jmethodID txObjMid = (*env)->GetMethodID(env, txClass, "<init>",                                                 "(JI[BJJJ[Ljava/lang/String;[Ljava/lang/String;J[J)V");//      if(BRWalletAmountReceivedFromTx(_wallet, transactions_sqlite[i]) == 0 && BRWalletAmountSentByTx(_wallet, transactions_sqlite[i])==0) continue;        jlong JtimeStamp = transactions_sqlite[i]->timestamp;        __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "transactions_sqlite[i]->timestamp: %d", transactions_sqlite[i]->timestamp);        jint JblockHeight = transactions_sqlite[i]->blockHeight;        __android_log_print(ANDROID_LOG_ERROR, "Message from C: !!!!!!!!!", "transactions_sqlite[i]->blockHeight: %d", transactions_sqlite[i]->blockHeight);        __android_log_print(ANDROID_LOG_ERROR, "Message from C: !!!!!!!!!", "JblockHeight: %d", JblockHeight);        jbyteArray JtxHash = (*env)->NewByteArray(env, sizeof(transactions_sqlite[i]->txHash));//        __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "uint256_hex_encode(transactions_sqlite[i]->txHash)h: %s",//                            uint256_hex_encode(transactions_sqlite[i]->txHash));        (*env)->SetByteArrayRegion(env, JtxHash, 0, sizeof(transactions_sqlite[i]->txHash),                                   (const jbyte *) &transactions_sqlite[i]->txHash);        jlong Jsent = (jlong) BRWalletAmountSentByTx(_wallet, transactions_sqlite[i]);//        __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "BRWalletAmountSentByTx(wallet, transactions_sqlite[i]): %d",//         BRWalletAmountSentByTx(_wallet, transactions_sqlite[i]));        jlong Jreceived = (jlong) BRWalletAmountReceivedFromTx(_wallet, transactions_sqlite[i]);        __android_log_print(ANDROID_LOG_ERROR, "Message from C: ",                            "BRWalletAmountReceivedFromTx(): %d",                            (int) BRWalletAmountReceivedFromTx(_wallet, transactions_sqlite[i]));        jlong Jfee = (jlong) BRWalletFeeForTx(_wallet, transactions_sqlite[i]);//        __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "BRWalletFeeForTx(wallet, transactions_sqlite[i]): %d",//                BRWalletFeeForTx(_wallet, transactions_sqlite[i]));        int outCountTemp = transactions_sqlite[i]->outCount;        jlongArray JoutAmounts = (*env)->NewLongArray(env, outCountTemp);        jobjectArray JtoAddresses = (*env)->NewObjectArray(env, outCountTemp, (*env)->FindClass(env,                                                                                                "java/lang/String"), 0);        int outCountAfterFilter = 0;        for (int j = 0; j < outCountTemp; j++) {            if(Jsent > 0) {                if (!BRWalletContainsAddress(_wallet, transactions_sqlite[i]->outputs[j].address)) {                    jstring str = (*env)->NewStringUTF(env,                                                       transactions_sqlite[i]->outputs[j].address);                    (*env)->SetObjectArrayElement(env, JtoAddresses, outCountAfterFilter, str);                    (*env)->SetLongArrayRegion(env, JoutAmounts, outCountAfterFilter++, 1,                                               (const jlong *) &transactions_sqlite[i]->outputs[j].amount);                }            } else {                if (BRWalletContainsAddress(_wallet, transactions_sqlite[i]->outputs[j].address)) {                    jstring str = (*env)->NewStringUTF(env,transactions_sqlite[i]->outputs[j].address);                    (*env)->SetObjectArrayElement(env, JtoAddresses, outCountAfterFilter, str);                    (*env)->SetLongArrayRegion(env, JoutAmounts, outCountAfterFilter++, 1,                                           (const jlong *) &transactions_sqlite[i]->outputs[j].amount);                }            }        }        int inCountTemp = transactions_sqlite[i]->inCount;        jobjectArray JfromAddresses = (*env)->NewObjectArray(                env, inCountTemp, (*env)->FindClass(env, "java/lang/String"), 0);        int inCountAfterFilter = 0;        for (int j = 0; j < inCountTemp; j++) {            if(Jsent > 0) {                jstring str = (*env)->NewStringUTF(env, transactions_sqlite[i]->inputs[j].address);                (*env)->SetObjectArrayElement(env, JfromAddresses, inCountAfterFilter++, str);            } else {                jstring str = (*env)->NewStringUTF(env, transactions_sqlite[i]->inputs[j].address);                (*env)->SetObjectArrayElement(env, JfromAddresses, inCountAfterFilter++, str);            }        }        jlong JbalanceAfterTx = (jlong) BRWalletBalanceAfterTx(_wallet, transactions_sqlite[i]);        jobject txObject = (*env)->NewObject(env, txClass, txObjMid, JtimeStamp, JblockHeight,                                             JtxHash, Jsent, Jreceived, Jfee, JtoAddresses,                                             JfromAddresses,                                             JbalanceAfterTx, JoutAmounts);        (*env)->SetObjectArrayElement(env, transactionObjects, txCount - 1 - i, txObject);    }    return transactionObjects;}JNIEXPORT jboolean JNICALL Java_com_breadwallet_wallet_BRWalletManager_validateAddress        (JNIEnv *env, jobject obj, jstring address) {    const char *str;    str = (char *) (*env)->GetStringUTFChars(env, address, NULL);//    __android_log_print(ANDROID_LOG_ERROR, "LOG_TAG", "Need to print : %s", str);    int result = BRAddressIsValid(str);    (*env)->ReleaseStringUTFChars(env, address, str);//    __android_log_print(ANDROID_LOG_ERROR, "LOG_TAG", "This is the result : %d", result);    return result ? JNI_TRUE : JNI_FALSE;}JNIEXPORT jboolean JNICALL Java_com_breadwallet_wallet_BRWalletManager_addressContainedInWallet        (JNIEnv *env, jobject obj, jstring address) {    if(!_wallet) return JNI_FALSE;    const char *str;    str = (char *) (*env)->GetStringUTFChars(env, address, NULL);    int result = BRWalletContainsAddress(_wallet, str);    (*env)->ReleaseStringUTFChars(env, address, str);    return result ? JNI_TRUE : JNI_FALSE;}JNIEXPORT jdouble JNICALL Java_com_breadwallet_wallet_BRWalletManager_getMinOutputAmount        (JNIEnv *env, jobject obj) {    return (jdouble) TX_MIN_OUTPUT_AMOUNT;}JNIEXPORT jboolean JNICALL Java_com_breadwallet_wallet_BRWalletManager_addressIsUsed        (JNIEnv *env, jobject obj, jstring address) {    if(!_wallet) return JNI_FALSE;    const char *str;    str = (char *) (*env)->GetStringUTFChars(env, address, NULL);    int result = BRWalletAddressIsUsed(_wallet, str);    (*env)->ReleaseStringUTFChars(env, address, str);    return result ? JNI_TRUE : JNI_FALSE;}JNIEXPORT jlong JNICALL Java_com_breadwallet_wallet_BRWalletManager_getMaxOutputAmount        (JNIEnv *env, jobject obj) {    return (jlong) BRWalletMaxOutputAmount(_wallet);}JNIEXPORT jint JNICALL Java_com_breadwallet_wallet_BRWalletManager_feeForTransaction        (JNIEnv *env, jobject obj, jstring address, jlong amount) {    if(!_wallet) return 0;    const char *rawAddress = (*env)->GetStringUTFChars(env, address, NULL);    BRTransaction *tx = BRWalletCreateTransaction(_wallet, (uint64_t) amount, rawAddress);    return tx ? (jint) BRWalletFeeForTx(_wallet, tx) : 0;}JNIEXPORT jbyteArray JNICALL Java_com_breadwallet_wallet_BRWalletManager_tryTransaction        (JNIEnv *env, jobject obj, jstring jAddress, jlong jAmount) {    if(!_wallet) return 0;    const char *rawAddress = (*env)->GetStringUTFChars(env, jAddress, NULL);    BRTransaction *tx = BRWalletCreateTransaction(_wallet, (uint64_t) jAmount, rawAddress);    if(!tx) return NULL;    uint8_t buf[BRTransactionSerialize(tx, NULL, 0)];    size_t len = BRTransactionSerialize(tx, buf, sizeof(buf));    jbyteArray result = (*env)->NewByteArray(env, len);    (*env)->SetByteArrayRegion(env, result, 0, len, (jbyte *)buf);    return result;}JNIEXPORT jboolean JNICALL Java_com_breadwallet_wallet_BRWalletManager_isCreated        (JNIEnv *env, jobject obj) {    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "wallet isCreated %s", _wallet ? "yes" : "no");    return _wallet ? JNI_TRUE : JNI_FALSE;}JNIEXPORT jboolean JNICALL Java_com_breadwallet_wallet_BRWalletManager_transactionIsVerified        (JNIEnv *env, jobject obj, jstring jtxHash) {    if(!_wallet) return JNI_FALSE;    const char *txHash = (*env)->GetStringUTFChars(env, jtxHash, NULL);    UInt256 txHashResult = uint256_hex_decode(txHash);    BRTransaction *tx = BRWalletTransactionForHash(_wallet, txHashResult);    int result = BRWalletTransactionIsVerified(_wallet, tx);    return result ? JNI_TRUE : JNI_FALSE;}JNIEXPORT jboolean Java_com_breadwallet_wallet_BRWalletManager_pay(JNIEnv *env, jobject thiz,                                                               jstring address,                                                               jlong amount,                                                               jstring strSeed) {    if(!_peerManager || !_wallet)  return JNI_FALSE;    const char *rawAddress = (*env)->GetStringUTFChars(env, address, NULL);    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "SENDING: address %s, amount %llu",                        rawAddress, amount);//    __android_log_print(ANDROID_LOG_ERROR,"in Pay", "rawAddress:%s,sizeof(rawAddress):%d\n", rawAddress, sizeof(rawAddress));    BRTransaction *tx = BRWalletCreateTransaction(_wallet, (uint64_t) amount, rawAddress);    if(!tx) return JNI_FALSE;    const char *rawString = (*env)->GetStringUTFChars(env, strSeed, 0);//    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "theSeed: address %s", rawString);    static UInt512 key = UINT512_ZERO;    BRBIP39DeriveKey(key.u8, rawString, NULL);    size_t seedSize = sizeof(key);    BRWalletSignTransaction(_wallet, tx, key.u8, seedSize);//    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "BRTransactionIsSigned(tx): %d, tx->txHash: %s", BRTransactionIsSigned(tx), uint256_hex_encode(tx->txHash));//    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "sign_result: %d", sign_result);    BRPeerManagerPublishTx(_peerManager, tx, NULL, callback);    return JNI_TRUE;}JNIEXPORT jlong Java_com_breadwallet_wallet_BRWalletManager_bitcoinAmount(JNIEnv *env, jobject thiz,                                                                             jlong localAmount,                                                                             double price) {    return (jlong) BRBitcoinAmount(localAmount, price);}JNIEXPORT jlong Java_com_breadwallet_wallet_BRWalletManager_localAmount(JNIEnv *env, jobject thiz,                                                                          jlong amount,                                                                          double price) {    return (jlong) BRLocalAmount(amount, price);}JNIEXPORT void Java_com_breadwallet_wallet_BRWalletManager_walletFreeEverything(JNIEnv *env, jobject thiz) {    if(_wallet){        BRWalletFree(_wallet);        _wallet = NULL;    }    _wallet = NULL;    if(_transactions)        free(_transactions);    _transactions = NULL;}JNIEXPORT jboolean JNICALL Java_com_breadwallet_wallet_BRWalletManager_validateRecoveryPhrase        (JNIEnv *env, jobject obj, jobjectArray stringArray, jstring jPhrase) {    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "validateRecoveryPhrase");    int wordsCount = (*env)->GetArrayLength(env, stringArray);    const char *wordList[wordsCount];    for (int i = 0; i < wordsCount; i++) {        jstring string = (jstring) (*env)->GetObjectArrayElement(env, stringArray, i);        const char *rawString = (*env)->GetStringUTFChars(env, string, 0);        wordList[i] = rawString;        (*env)->DeleteLocalRef(env, string);        // Don't forget to call `ReleaseStringUTFChars` when you're done.    }    const char *str = (*env)->GetStringUTFChars(env, jPhrase, NULL);    return BRBIP39PhraseIsValid(wordList, str) ? JNI_TRUE : JNI_FALSE;}JNIEXPORT jstring Java_com_breadwallet_wallet_BRWalletManager_getFirstAddress(JNIEnv *env,                                                                                jobject thiz,                                                                                jbyteArray bytePubKey) {    BRMasterPubKey mpk;    BRAddress address = BR_ADDRESS_NONE;//    int pubKeyLength = (*env)->GetArrayLength(env, bytePubKey);    jbyte *pubKeyBytes = (*env)->GetByteArrayElements(env, bytePubKey, 0);    mpk = *(BRMasterPubKey *) pubKeyBytes;    uint8_t pubKey[33];    BRBIP32PubKey(pubKey, sizeof(pubKey), mpk, 0, 0);    BRKey key;    BRKeySetPubKey(&key, pubKey, sizeof(pubKey));    BRKeyAddress(&key, address.s, sizeof(address));//    size_t BRBIP32PubKey(uint8_t *pubKey, size_t pubKeyLen, BRMasterPubKey mpk, int internal, uint32_t index)//    int BRKeySetPubKey(BRKey *key, const uint8_t *pubKey, size_t len)//    size_t BRKeyAddress(BRKey *key, char *addr, size_t len)    return (*env)->NewStringUTF(env, address.s);}JNIEXPORT jboolean Java_com_breadwallet_wallet_BRWalletManager_publishSerializedTransaction(JNIEnv *env,                                                                                jobject thiz,                                                                                jbyteArray serializedTransaction,                                                                                jstring phrase) {    if(!_peerManager) return JNI_FALSE;    int txLength = (*env)->GetArrayLength(env, serializedTransaction);    jbyte *byteTx = (*env)->GetByteArrayElements(env, serializedTransaction, 0);    BRTransaction *tmpTx = BRTransactionParse((uint8_t *) byteTx, txLength);    if(!tmpTx) return JNI_FALSE;    const char *rawString = (*env)->GetStringUTFChars(env, phrase, 0);    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "rawString: %s", rawString);    static UInt512 key = UINT512_ZERO;    BRBIP39DeriveKey(key.u8, rawString, NULL);    size_t seedSize = sizeof(key);    BRWalletSignTransaction(_wallet, tmpTx, key.u8, seedSize);    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "BRTransactionIsSigned(tmpTx): %d", BRTransactionIsSigned(tmpTx));    if(!tmpTx) return JNI_FALSE;    BRPeerManagerPublishTx(_peerManager, tmpTx, NULL, callback);    return JNI_TRUE;}//void printBits(unsigned int num) {//    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "\n\n");//    while (num) {//        if (num & 1)//            __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "1");//        else//            __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "0");//        num >>= 1;//    }//    __android_log_print(ANDROID_LOG_ERROR, "Message from C: ", "\n\n");//}